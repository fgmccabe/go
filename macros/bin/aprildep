#!/usr/bin/perl -w

use Getopt::Long;
use FileHandle;
use strict;
use Text::Wrap;
use vars qw/@includepath $doSystemIncludes/;

@includepath = ();
$Text::Wrap::columns = 72;

$doSystemIncludes = 1;

sub readfile ($) {
    my $filename =shift;
    if (!open FILE, "<$filename") {
	warn "failed to open $filename for reading\n";
	return ();
    }
    my @lines = <FILE>;
    close FILE;
    return @lines;
}

sub findDep ($ ) {
    my $filename = shift;
    foreach my $prefix (@includepath,) {
	my $potential = "$prefix$filename";
	return $potential if (-f $potential);
    }
    return $filename;
}

sub findDeps {
    my @deps = ();
    my %done = (); 

    foreach my $source (@_) {
	my @lines = readfile($source);
	local $_ = join "", @lines;
	
	# strip out comments 
	s/--.*\n//g;
	s%/\*.*?\*/%%g;
	
	my $x = 0;
	do {
	    my $isSystemInclude = 0;

	    if (($x = s/\#include\s+"(.*?)"//) ||
		($x = s/interface\s+"(.*?)"//) ||
		($doSystemIncludes && ($isSystemInclude = 1) &&
		 ($x = s/\#include\s+\<"(.*?)"\>//) ||
		 ($x = s/interface\s+\<"(.*?)"\>//) ||
		 ($x = s/\#include\s+\<(.*?)\>//) ||
		 ($x = s/interface\s+\<(.*?)\>//))) {
		my $dep = findDep($1);
		push @deps, $dep
		  if (!$isSystemInclude or -f $dep);
		push @_, $dep
		  if ($dep =~ /\.ah$/ && -f $dep);
	    }
	    
	} while ($x);
    }
    @deps;
}

sub gendep ($) {
    my ($source) = @_;

    my $target = $source;
    my @deps = findDeps($source);

    my $interface = $source;
    $target =~ s/\.ap$//;
    $interface =~ s/\.ap$/\.af/;

    my $line = "$source @deps";
    $line = wrap("\t", "\t", $line);
    $line =~ s%\n\t% \\\n\t%g;
    return "$target $target.aam $interface: \\\n" . "$line\n\n";
}

sub usage() {
    print "usage: $0 [--output <filename>] [--include <dir>] [--force] [--symbolic] files...\n";
}

sub later {
    my ($what, @than) = @_;

    my $latest;
    foreach my $t (@than) {
	my $time = -M $t;
	$latest ||= $time;
	$latest = $time if ($time < $latest);
    }

    my $wtime = -M $what;

    if ($wtime && $latest) {
	return ($wtime < $latest);
    }
    else {
	return 0;
    }
}

sub identicalCommandLine ($$) {
    my ($new, $file) = @_;
    my $old = "";
    open FILE, "<$file";
    while (<FILE>) {
	if (/^\#\s*command-line:\s*(.*)$/i) {
	    $old = $1;
	    chomp $old;
	    last;
	}
    }
    close FILE;
    return $old eq $new;
}

sub main() {
    my $output;
    my $help;
    my $force = 0;
    my $symbolic = 1;
    my $commandline = "@ARGV";

    my $result = GetOptions("output=s" => \$output,
			    "include=s@" => \@includepath,
			    "symbolic" => \$symbolic,
			    "force" => \$force,
			    "help" => \$help);

    # process the includse for : separated lists
    @includepath = map split(/:/), @includepath;

    if ($help || @ARGV == 0 || !defined($result)) {
	usage();
	exit 1;
    }

    @ARGV = grep { 
	if (-f $_) { 1 }
	else {
	    warn "$0: warning: could not find file $_\n";
	    0;
	}
    } @ARGV;

    @includepath = ("", map "$_/", @includepath  );

    # Some standard system locations
    my $aprildir = $ENV{'APRIL_DIR'} || $ENV{'APRILDIR'} || "/opt/april";
    my $dxdir = $ENV{'DIALOX_DIR'} || $ENV{'DXDIR'} || "/opt/dialox";

    if ($doSystemIncludes) {
	@includepath = (@includepath, "${aprildir}/include/", "${dxdir}/include/");
    }

    my $fh = *STDOUT{IO};
    if ($output) {
	if (!$force && -f $output && later($output, @ARGV) && 
	    identicalCommandLine($commandline, $output)) {
	    # no need to generate dependencies
	    return 0;
	}

	$fh = new FileHandle "> $output" 
	  or die "failed to open $output for writing";
    }

    $fh->print("# april dependencies auto-generated by aprildep\n");
    $fh->print("# command-line: $commandline\n\n");

    foreach my $f (@ARGV) {
	my $l = gendep($f);
	if ($symbolic) {
	    $l =~ s/$aprildir/\$(APRILDIR)/gs;
	    $l =~ s/$dxdir/\$(DXDIR)/gs;
	}
	$fh->print($l);
    }

    $fh->close();
    return 0;
}

exit main();
