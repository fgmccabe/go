\begin{thenomenclature} 

 \nomgroup{A}

  \item [{\bf action procedure}]\begingroup A set of rules that defines a behavior in a program. Contrast, for example, with a \emph {predicate} program which defines a relation.\nomeqref {5.0}
		\nompageref{93}
  \item [{\bf bag of}]\begingroup A list-valued expression whose value is determined by finding all solutions to a predicate condition.\nomeqref {3.9}
		\nompageref{67}
  \item [{\bf basket}]\begingroup A basket type lattice is one where every chain is exactly three elements long; effectively meaning that there is no significant subtype relationship between non-trivial type elements.\nomeqref {2.0}
		\nompageref{36}
  \item [{\bf bounded set}]\begingroup A list valued expression whose value is determined by applying a predicate test to all elements of a base list.\nomeqref {3.10}
		\nompageref{68}
  \item [{\bf callback}]\begingroup A \emph {callback} is an interface that is implemented by the client code of an interface. Typically, callbacks are used to allow a library package to invoke specific functionality within the client to act as a kind of test. Callbacks are the object ordered analogue of lambda functions being passed in to higher order processing functions such as list map.\nomeqref {13.0}
		\nompageref{208}
  \item [{\bf cell}]\begingroup A primitive resource that supports a re-assignable memory model.\nomeqref {13.0}
		\nompageref{202}
  \item [{\bf chain}]\begingroup A chain is a sequence of types where for each pair of types in the link \emph {T\subi } and \emph {T\sub {i+1}} it known that \emph {T\subi } is a subtype of \emph {T\sub {i+1}}. All types are in a chain of at least three elements: \q {void}, the type itself and \q {top}.\nomeqref {2.0}
		\nompageref{36}
  \item [{\bf char\-act\-er cat\-ago\-ries}]\begingroup A classification of characters introduced by the Unicode consortium to abstract common roles of character glyphs.\nomeqref {1.0}
		\nompageref{4}
  \item [{\bf class label}]\begingroup A class label is a term that is associated with a theory -- a set of axioms that collectively describes a concept.\nomeqref {7.0}
		\nompageref{122}
  \item [{\bf conditional}]\begingroup A form of condition that applies a test to select one of two branches to apply. There are conditional forms of expression, action, predicate and grammar condition.\nomeqref {5.10}
		\nompageref{98}
  \item [{\bf conditional expression}]\begingroup An expression whose value is one of two possible values -- depending on the success or otherwise of a predicate test.\nomeqref {3.11}
		\nompageref{69}
  \item [{\bf exception recovery expression}]\begingroup An expression which incorporates a exception handler -- if an exception is \q {raise}d during the evaluation of an expression then its evaluation is terminated and an error handler executed instead.\nomeqref {3.15}
		\nompageref{76}
  \item [{\bf fluent}]\begingroup A \emph {fluent} is a predicate with a particular extent in time: fluents have a starting time and an ending time (although it may not always be clear what those end points are in all situations.)\nomeqref {15.0}
		\nompageref{242}
  \item [{\bf forall}]\begingroup A condition that is satisfied if a dependent goal is satisfied whenever the governing goal is satisfied. For example, all the children of someone are male, is a typical forall condition.\nomeqref {4.16}
		\nompageref{87}
  \item [{\bf guarded pattern}]\begingroup A pattern whose semantics is governed by a predicate: a unification or pattern match of the pattern with a term is deemed to succeed only if the guard is satisfied.\nomeqref {3.12}
		\nompageref{72}
  \item [{\bf negation}]\begingroup A predication which is satisfied iff its embedded predication is \emph {not} satisfied. \go uses negation-as-failure semantics negation.\nomeqref {4.14}
		\nompageref{87}
  \item [{\bf non-terminals}]\begingroup A part of a grammar that is itself defined by other grammar rules.\nomeqref {6.0}
		\nompageref{109}
  \item [{\bf one-of}]\begingroup A predicate condition that may only be satisfied once -- the evaluation will not seek alternate solutions to a one-of condition once a successful solution has been found.\nomeqref {4.15}
		\nompageref{87}
  \item [{\bf package}]\begingroup A package is a group of related definitions and programs that is separately compiled and loaded. Packages may contain classes, rules and types. Packages are accessed with the \q {import} statement.\nomeqref {8.0}
		\nompageref{139}
  \item [{\bf polymorphic}]\begingroup A type that is not completely ground -- it may refer to many kinds of values.\nomeqref {2.0}
		\nompageref{37}
  \item [{\bf predication}]\begingroup A syntax form that expresses a condition that must be satisfied.\nomeqref {4.4}
		\nompageref{82}
  \item [{\bf raise exception expression}]\begingroup Not a normal expression -- evaluation of a \q {raise} exception expression results in the exception being raised -- and the current evaluation aborted up to an enclosing exception handler. The value of the \q {raise} exception expression is used by the exception handler.\nomeqref {3.16}
		\nompageref{77}
  \item [{\bf recursive}]\begingroup A recursive type is one which may have components of the same type as the overall type.\nomeqref {2.0}
		\nompageref{37}
  \item [{\bf spawn expression}]\begingroup An expression denoting an action that has been spawned to executed as an independent thread of execution.\nomeqref {3.14}
		\nompageref{76}
  \item [{\bf strong clause}]\begingroup A form of clause that has an if-and-only-if semantics. All clauses in a predicate must be either regular or strong. In the latter case, the predicate is assumed to be formed of mutually exclusive cases -- each determined by a single strong clause.\nomeqref {4.1}
		\nompageref{80}
  \item [{\bf terminals}]\begingroup An atomic element of a stream that a grammar is processing.\nomeqref {6.0}
		\nompageref{109}
  \item [{\bf theta environment}]\begingroup A theta environment is a set of mutually recursive definitions that make up the definitions of a class or package.\nomeqref {7.0}
		\nompageref{123}
  \item [{\bf transport protocol}]\begingroup A mechanism used to access a resource or to deliver messages between applications.\nomeqref {14.0}
		\nompageref{215}
  \item [{\bf type annotated expression}]\begingroup An expression whose type is explicitly marked by the programmer.\nomeqref {3.8}
		\nompageref{67}
  \item [{\bf type assignment}]\begingroup A type assignment of an expression is a mapping from the expression to a type term.\nomeqref {2.0}
		\nompageref{34}
  \item [{\bf type constraints}]\begingroup a type constraint is a predicate that must be satisfied if the program is to be \emph {type safe}.\nomeqref {2.0}
		\nompageref{34}
  \item [{\bf type expression}]\begingroup A type expression is a term that \emph {denotes} a type. A simple type expression would be something like the symbol \q {char} -- which denotes the type of character expressions. A more complex example would be \q {list[char]} which denotes lists of characters -- i.e., strings.\nomeqref {2.0}
		\nompageref{33}
  \item [{\bf type inference}]\begingroup A process for determining whether a program is type safe or not. A type-unsafe program \emph {might} be able to compute a value, but is likely to not be able to compute a valid value.\nomeqref {2.0}
		\nompageref{38}
  \item [{\bf type inference}]\begingroup Type inference is the process by which a type expression can be \emph {automatically} assigned to an identifier or expression \emph {without} requiring that the type of the identifier be explicitly declared.\nomeqref {2.0}
		\nompageref{34}
  \item [{\bf type interface}]\begingroup An interface is associated with a type that defines the legal operations on values of that type. More specifically, the interface defines the expressions possible on the right hand side of a `dot' expression.\nomeqref {2.0}
		\nompageref{33}
  \item [{\bf type lattice}]\begingroup a partial ordering with an identified \q {top} element that is bigger than all others, and a bottom element \q {void} that is smaller than all other elements.\nomeqref {2.0}
		\nompageref{35}
  \item [{\bf valof expression}]\begingroup An expression whose value is determined as a result of executing an action.\nomeqref {3.13}
		\nompageref{75}

\end{thenomenclature}
