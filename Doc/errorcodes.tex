\chapter{Standard error codes}
\label{errorcodes}
\section{Error handling}
  
Many of the built-in primitives may raise an exception as an alternative to failing or succeeding. This is primarily for those situations where a failure would not represent an appropriate response. For example, an attempt to divide by zero will result in a error exception.
  
Error exceptions may be trapped by user-level \go\ programs (see errorhanding); or in the final analysis an uncaught exception will cause the \go\ application to be terminated.

The description for each built-in primitive gives a listing of the different error \q{code}s generated by that primitive. In this section we give a complete listing of the standard error codes and some explanation of the meaning of the error.

\subsection{The standard \q{exception} type}
\label{error:exception}
\index{exception@\q{exception} type}
Exceptions raised, either internally by a library function or explicitly in a user-level program, are represented by \q{exception[]} values. This interface is defined as:
\begin{alltt}
exception \impl \{ cause:[]=>string. code:[]=>symbol \}.
\end{alltt}
\label{errortype}
The \q{cause} function returns a string representing a reason for the exception; however, for most programs the \q{code} function represents a more language-neutral of determining the kind of exception.

In addition to the \q{exception} type, \go also defines in its standard library the \q{error} constructor. This class is used by most of the built-in functions when they wish to report an error to the caller of the function:
\begin{alltt}
error:[string,symbol]\$=exception.
error(R,C)..\{
  cause()=>R.
  code()=>C.
  show()=>"error: "<>R<>": ("<>__errorcode(C)<>")".
\}
\end{alltt}
 
\section{Standard exception code symbols}

\begin{description}

\item[\constant{'eABORT'}]
\label{eABORT}

The \constant{eEOF} error exception is raised when the user has requested that a thread be aborted. This is typically only possible if the program is being debugged.

\item[\constant{'eASSIGN'}]
\label{eASSIGN}
  
The \constant{eASSIGN} is raised when a program attempts to assign to a variable when it is not permitted. Assignment is only permitted within action rules that are executed `at the top level' of a thread; in particular, assignment is not permitted within \q{action} sequences or \q{valof} sequences. 

\item[\constant{'eCFGERR'}]
\label{eCFGERR}
  
The \constant{eCFGERR} is raised when a  configuration  request was no possible. A standard place where this occurs in the file I/O system; \go attempts to ensure that it can access external files in a non-blocking interrupt driven mode. If that is not possible then a \q{eCFGERR} error exception will be raised.

THe \q{eCFGERR} error is also raised when there is a conflict between the configuration of a channel and the attempted operation on it; for example, attempting to read or write encoded terms to channels that are not configured to \q{rawEncoding} mode will result in this error.

\item[\constant{'eCHRNEEDD'}]
\label{eCHRNEEDD}
  
The \constant{eCHRNEEDD} is raised when an argument to a primitive is not a \q{char} value -- this normally means that a \q{char} was expected but an unbound variable was passed in. 
  
\item[\constant{'eCODE'}]
\label{eCODE}
  
The \constant{eCODE} is raised when attempting to execute something which is not executable -- most commonly when trying to call an unbound variable.
  
The nature of the \go\ language means that it is not always possible to determine at compile time that all `program variables' are bound to executable code. As a result, on occasion, one may find an \constant{'eCODE'} error being raised.

\item[\constant{'eCONNECT'}]
\label{eCONNECT}
  
The \constant{eCONNECT} is raised when attempting to perform a connection to a remote server and it is denied for some reason. The actual problem will vary, from the server not actually listening to the port to the server not permitting you to make the connection.
  
\item[\constant{'eDEAD'}]
\label{eDEAD}

The \constant{eDEAD} exception is raised when a deadlock is detected. This occurs principally when using locks and the \q{sync} action. It is especially easy to get into a `deadlock' situation when attempting to \q{sync} on more than one lock; in that situation make sure that the nesting order of \q{sync} actions is the same for all occurrences.

For example, if one action sequence is:
\begin{alltt}
sync(L\sub1)\{
  sync(L\sub2)\{
    \emph{Action\sub1}
  \}
\}
\end{alltt}
and another action sequence -- executing in another thread -- using the same locks is:
\begin{alltt}
sync(L\sub2)\{
  sync(L\sub1)\{
    \emph{Action\sub2}
  \}
\}
\end{alltt}
then a deadlock is possible because both sequences may execute their first \q{sync} action; but then they will both be deadlocked on their second \q{sync}.

Deadlock detection is not infallible, as it relies on the fact that there are no other executable processes. It is quite possible for two threads to deadlock, but to have other threads active at the same time.

\item[\constant{'eDIVZERO'}]
\label{eDIVZERO}
  
The \constant{eDIVZERO} error is raised by builtin primitives when the application program attempts to divide a number by 0.
  
For example, a call of the form:
\begin{alltt}
\ldots,foo(1/0),\ldots
\end{alltt}
would result in an \constant{eDIVZERO} error. An active error handler would have to have a clause that matched:
\begin{alltt}
error("/",'eDIVZERO') :- \ldots
\end{alltt}
to catch this error.

%\item[\constant{'eDUPLICATE'}]
%\label{eDUPLICATE}
%  
%The \constant{eDUPLICATE} is raised when a duplicate request is issued. For example, attempting to \q{spawn} a process with a named handle that is already executing in the same invokation will cause an \constant{eDUPLICATE} error to be raised.

\item[\constant{'eEOF'}]
\label{eEOF}

The \constant{eEOF} error exception is raised when an attempt is made to read past the end of file of some input file.

\item[\constant{'eFAIL'}]
\label{eFAIL}

The \constant{eFAIL} error is raised when a function or a procedure fails. Functions are assumed to be `total' on their arguments and if none of the equations in a function definition apply to the arguments then an \q{'eFAIL'} error exception will be raised. Similarly, if none of the action rules in a procedure match the arguments then, rather than backtracking, an \q{'eFAIL'} error is also raised.

Recall that the heads of both equations and action rules are \emph{matched} against the arguments of the calls rather than being unified (see Section~\vref{expression:matching:unification}). This has the effect of increasing the probability of a call to a function or procedure failing -- since matching is not permitted to bind variables in the call. However, such a `success' in the case of functions and procedures would likely be erroneous since long tradition has it that functions do not `side-effect' their arguments.

For example, in the function \q{fact} below, there are rules for the case of zero and for positive numbers, but no case for negative numbers:
\begin{alltt}
fact(0)=>1.
fact(N)::N>0 => N*fact(N-1).
\end{alltt}
A call to the \q{fact} function with a negative argument would raise the error:
\begin{alltt}
error("fact",'eFAIL')
\end{alltt}

\item[\constant{'eINSUFARG'}]
\label{eINSUFARG}
  
The \constant{eINSUFARG} is raised when an argument to a primitive is insufficiently instantiated. Typically this is when an argument is a variable when it should not be.
  
\item[\constant{'eINSUFTPE'}]
\label{eINSUFTPE}
  
The \constant{eINSUFTPE} is raised when the type associated with an \q{??} expression is non-ground. In general, non-ground types are not safe when wrapped in an \q{??} expression.

\item[\constant{'eINTNEEDD'}]
\label{eINTNEEDD}
  
The \constant{eINTNEEDD} is raised when an argument to a primitive is not a whole number. Typically this is raised by primitives such as \function{band} which implement a bitmap interpretation of numeric values (see \vref{arith:band}).
  
\item[\constant{'eINVAL'}]
\label{eINVAL}\constant{'eINVAL'}
  
The \constant{eINVAL} is raised when an argument to a primitive is not valid for some reason. 
  
\item[\constant{'eINVCODE'}]
\label{eINVOCDE}
  
The \constant{eINVCODE} is raised when a particular type of program is expected and the actual type is incorrect.

\item[\constant{'eIOERROR'}]
\label{eIOERROR}
  
The \constant{eIOERROR} is raised when there is an operating system error to do with I/O. Typically, this is caused when the device being written to is full, or when a socket connection `breaks'.
  
\item[\constant{'eLSTNEEDD'}]
\label{eLSTNEEDD}
  
The \constant{eLSTNEEDD} is raised when an argument to a primitive is not a list. 
  
\item[\constant{'eNOFILE'}]
\label{eNOFILE}
  
The \constant{eNOFILE} is raised when attempting to access a resource (typically a file) which does not exists.
  
\item[\constant{'eNOPERM'}]
\label{eNOPERM}
  
The \constant{eNOPERM} is raised when attempting to access a resource for which the task (or the user running the \go application) does not have permission.
  
\item[\constant{'eNOTFND'}]
\label{eNOTFND}
  
The \constant{eNOTFND} is raised when a file or other system resource is not found.
  
\item[\constant{'eNUMNEEDD'}]
\label{eNUMNEEDD}
  
The \constant{eNUMNEEDD} is raised when an argument to a primitive is not a number. 

\item[\constant{'eOCCUR'}]
\label{eOCCUR}

The \constant{eOCCUR} exception is raised when a unification attempts to construct a `circular' term. For example, unifying \q{X} with \q{f(X)} would result in an infinite structure if permitted. This is the so-called `occurs check' violation.

Most logic programming systems do not even check for occurs check because of the potential run-time overhead. However, it is not safe, and the \go system attempts to avoid to perform the check when it is known to be safe (such as the first time a variable is unified).

\item[\constant{'eRANGE'}]
\label{eRANGE}
  
The \constant{eRANGE} is raised when an argument to a primitive is out of the range of permissable values for that particular operation.

\item[\constant{'eSPACE'}]
\label{eSPACE}

The \constant{eSPACE} exception is raised if the system cannot function in the amount of memory it has. This is generally a fatal error.
  
\item[\constant{'eSTRNEEDD'}]
\label{eSTRNEEDD}
  
The \constant{eSTRNEEDD} is raised when an argument to a primitive is not a list of symbols -- i.e., when it is not a string.
  
\item[\constant{'eSYMNEEDD'}]
\label{eSYMNEEDD}
  
The \constant{eSYMNEEDD} is raised when an argument to a primitive is not a symbol.


\item[\constant{'eSYSTEM'}]
\label{eSYSTEM}

The \constant{eSYSTEM} error exception is raised when a system limit is exceeded. A typical case of this is when unifying terms that are so complex that internal buffers are exceeded.

Note that not all system overflows result in a `recoverable' exception. If total system memory is exhausted, for example, then an unrecoverable error is raised and the \go engine will be terminated.
    
\item[\constant{'eVARNEEDD'}]
\label{eVARNEEDD}
  
The \constant{eVARNEEDD} is raised when an argument to a primitive is not an unbound variable -- and the primitive is not able to handle unification.
  
\item[\constant{'eUNIFY'}]
\label{eUNIFY}
  
The \constant{eUNIFY} is raised when attempting to compare two `incomparible' values -- such as two code values. Although \go\ is a higher-order language, it is not a complete higher-order language -- in the sense that higher-order unification is not part of the language.\footnote{Higher order unification is not decidable; which makes incorporating it into a programming language problematical.} Whenever two code values -- such as functions or relations -- are compared then an \constant{eUNIFY} error exception will be raised.

\end{description}
