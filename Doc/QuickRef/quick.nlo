\nomenclatureentry{a\bf type expression@[{\bf type expression}]\begingroup A type expression is a term that \emph {denotes} a type. A simple type expression would be something like the symbol \q {char} -- which denotes the type of character expressions. A more complex example would be \q {list[char]} which denotes lists of characters -- i.e., strings.\nomeqref {2.0}|nompageref}{19}
\nomenclatureentry{a\bf type interface@[{\bf type interface}]\begingroup An interface is associated with a type that defines the legal operations on values of that type. More specifically, the interface defines the expressions possible on the right hand side of a `dot' expression.\nomeqref {2.0}|nompageref}{19}
\nomenclatureentry{a\bf type assignment@[{\bf type assignment}]\begingroup A type assignment of an expression is a mapping from the expression to a type term.\nomeqref {2.0}|nompageref}{20}
\nomenclatureentry{a\bf type constraints@[{\bf type constraints}]\begingroup a type constraint is a predicate that must be satisfied if the program is to be \emph {type safe}.\nomeqref {2.0}|nompageref}{20}
\nomenclatureentry{a\bf type lattice@[{\bf type lattice}]\begingroup a partial ordering with an identified \q {top} element that is bigger than all others, and a bottom element \q {void} that is smaller than all other elements.\nomeqref {2.0}|nompageref}{21}
\nomenclatureentry{a\bf chain@[{\bf chain}]\begingroup A chain is a sequence of types where for each pair of types in the link \emph {T\subi } and \emph {T\sub {i+1}} it known that \emph {T\subi } is a subtype of \emph {T\sub {i+1}}. All types are in a chain of at least three elements: \q {void}, the type itself and \q {top}.\nomeqref {2.0}|nompageref}{22}
\nomenclatureentry{a\bf basket@[{\bf basket}]\begingroup A basket type lattice is one where every chain is exactly three elements long; effectively meaning that there is no significant subtype relationship between non-trivial type elements.\nomeqref {2.0}|nompageref}{23}
\nomenclatureentry{a\bf polymorphic@[{\bf polymorphic}]\begingroup A type that is not completely ground -- it may refer to many kinds of values.\nomeqref {2.0}|nompageref}{23}
\nomenclatureentry{a\bf recursive@[{\bf recursive}]\begingroup A recursive type is one which may have components of the same type as the overall type.\nomeqref {2.0}|nompageref}{23}
\nomenclatureentry{a\bf type annotated expression@[{\bf type annotated expression}]\begingroup An expression whose type is explicitly marked by the programmer.\nomeqref {3.0}|nompageref}{46}
\nomenclatureentry{a\bf bag of@[{\bf bag of}]\begingroup A list-valued expression whose value is determined by finding all solutions to a predicate condition.\nomeqref {3.0}|nompageref}{46}
\nomenclatureentry{a\bf bounded set@[{\bf bounded set}]\begingroup A list valued expression whose value is determined by applying a predicate test to all elements of a base list.\nomeqref {3.0}|nompageref}{47}
\nomenclatureentry{a\bf conditional expression@[{\bf conditional expression}]\begingroup An expression whose value is one of two possible values -- depending on the success or otherwise of a predicate test.\nomeqref {3.0}|nompageref}{47}
\nomenclatureentry{a\bf guarded pattern@[{\bf guarded pattern}]\begingroup A pattern whose semantics is governed by a predicate: a unification or pattern match of the pattern with a term is deemed to succeed only if the guard is satisfied.\nomeqref {3.0}|nompageref}{48}
\nomenclatureentry{a\bf valof expression@[{\bf valof expression}]\begingroup An expression whose value is determined as a result of executing an action.\nomeqref {3.0}|nompageref}{49}
\nomenclatureentry{a\bf spawn expression@[{\bf spawn expression}]\begingroup An expression denoting an action that has been spawned to executed as an independent thread of execution.\nomeqref {3.0}|nompageref}{50}
\nomenclatureentry{a\bf exception recovery expression@[{\bf exception recovery expression}]\begingroup An expression which incorporates a exception handler -- if an exception is \q {raise}d during the evaluation of an expression then its evaluation is terminated and an error handler executed instead.\nomeqref {3.0}|nompageref}{50}
\nomenclatureentry{a\bf raise exception expression@[{\bf raise exception expression}]\begingroup Not a normal expression -- evaluation of a \q {raise} exception expression results in the exception being raised -- and the current evaluation aborted up to an enclosing exception handler. The value of the \q {raise} exception expression is used by the exception handler.\nomeqref {3.0}|nompageref}{50}
\nomenclatureentry{a\bf strong clause@[{\bf strong clause}]\begingroup A form of clause that has an if-and-only-if semantics. All clauses in a predicate must be either regular or strong. In the latter case, the predicate is assumed to be formed of mutually exclusive cases -- each determined by a single strong clause.\nomeqref {4.0}|nompageref}{54}
\nomenclatureentry{a\bf predication@[{\bf predication}]\begingroup A syntax form that expresses a condition that must be satisfied.\nomeqref {4.0}|nompageref}{55}
\nomenclatureentry{a\bf negation@[{\bf negation}]\begingroup A predication which is satisfied iff its embedded predication is \emph {not} satisfied. \go uses negation-as-failure semantics negation.\nomeqref {4.0}|nompageref}{58}
\nomenclatureentry{a\bf one-of@[{\bf one-of}]\begingroup A predicate condition that may only be satisfied once -- the evaluation will not seek alternate solutions to a one-of condition once a successful solution has been found.\nomeqref {4.0}|nompageref}{58}
\nomenclatureentry{a\bf forall@[{\bf forall}]\begingroup A condition that is satisfied if a dependent goal is satisfied whenever the governing goal is satisfied. For example, all the children of someone are male, is a typical forall condition.\nomeqref {4.0}|nompageref}{58}
\nomenclatureentry{a\bf action procedure@[{\bf action procedure}]\begingroup A set of rules that defines a behavior in a program. Contrast, for example, with a \emph {predicate} program which defines a relation.\nomeqref {5.0}|nompageref}{61}
\nomenclatureentry{a\bf conditional@[{\bf conditional}]\begingroup A form of condition that applies a test to select one of two branches to apply.\nomeqref {5.0}|nompageref}{63}
\nomenclatureentry{a\bf class label@[{\bf class label}]\begingroup A class label is a term that is associated with a theory -- a set of axioms that collectively describes a concept.\nomeqref {7.0}|nompageref}{74}
\nomenclatureentry{a\bf theta environment@[{\bf theta environment}]\begingroup A theta environment is a set of mutually recursive definitions that make up the definitions of a class or package.\nomeqref {7.0}|nompageref}{76}
\nomenclatureentry{a\bf package@[{\bf package}]\begingroup A package is a group of related definitions and programs that is separately compiled and loaded. Packages may contain classes, rules and types. Packages are accessed with the \q {import} statement.\nomeqref {8.0}|nompageref}{95}
\nomenclatureentry{a\bf cell@[{\bf cell}]\begingroup A primitive resource that supports a re-assignable memory model.\nomeqref {13.0}|nompageref}{163}
\nomenclatureentry{a\bf callback@[{\bf callback}]\begingroup A \emph {callback} is an interface that is implemented by the client code of an interface. Typically, callbacks are used to allow a library package to invoke specific functionality within the client to act as a kind of test. Callbacks are the object ordered analogue of lambda functions being passed in to higher order processing functions such as list map.\nomeqref {13.0}|nompageref}{170}
\nomenclatureentry{a\bf transport protocol@[{\bf transport protocol}]\begingroup A mechanism used to access a resource or to deliver messages between applications.\nomeqref {14.0}|nompageref}{179}
\nomenclatureentry{a\bf fluent@[{\bf fluent}]\begingroup A \emph {fluent} is a predicate with a particular extent in time: fluents have a starting time and an ending time (although it may not always be clear what those end points are in all situations.)\nomeqref {15.0}|nompageref}{214}
